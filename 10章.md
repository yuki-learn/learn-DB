# 10章まとめ：インデックスとデータマート

## 1. 基本

* **B-Treeインデックス**
    * RDBの標準的なインデックス。
    * **長所:** キー値の間で検索速度にばらつきが少ない（計算量が $O(\log N)$ で安定）。
    * **特徴:** 等号（`=`）だけでなく、範囲検索（`>`, `<`, `BETWEEN`）も高速。
* **カーディナリティ（選択率）**
    * 「値のばらつき具合」のこと。
    * **高い:** `すべての行について値が異なる一意キー` など。インデックスの効果が高い。
    * **低い:** 性別（男・女）やフラグ（ON・OFF）など。インデックスの効果が薄い。

---

## 2. インデックスがあまり意味ないケース

* **絞り込み条件が存在しない `SELECT`**
    * 全件取得なら、インデックスを読むよりテーブルを直接フルスキャンした方が速い。
* **カーディナリティが低く、多くのレコードがヒットする場合**
    * 目安として、**全体の20%〜30%以上**のデータを取得する場合、DBは「インデックスを使うと逆に遅い（ランダムアクセス多発）」と判断し、インデックスを無視してテーブルスキャンを選ぶ。
    * 例：100万件中、80万件ある「男」を抽出する場合など。
* **パラメータによって選択率が大きく変わる場合**
    * 「昨日のデータ（数件）」ならインデックスが速いが、「過去10年分（全件に近い）」ならスキャンが速い。この判断がブレて性能が不安定になることがある（パラメータスニッフィング）。

---

## 3. インデックスが「使えない」書き方（アンチパターン）

以下の書き方をすると、インデックス列であってもフルスキャンが発生してしまう。

* **中間一致・後方一致のLIKE検索**
    * `WHERE col LIKE '%鈴木%'`
    * `WHERE col LIKE '%鈴木'`
    * ※ `LIKE '鈴木%'` （前方一致）ならインデックスは使える。
* **インデックス列に対する演算・関数適用**
    * ✕ `WHERE col * 1.1 > 100` （列を加工しているため不可）
    * 〇 `WHERE col > 100 / 1.1` （右辺で計算すればインデックス有効！）
    * ✕ `WHERE LEN(col) > 10`
* **`IS NULL` 検索**
    * 一般的にはインデックスが効きにくいとされる。
    * ※ただし、DBMSによってはNULLもインデックスに含まれるため、NULLの件数が非常に少なければ効くこともある。
* **否定形 (`<>`, `!=`, `NOT IN`)**
    * `WHERE col <> 100`
    * 「100以外全部」ということは、データの大部分を読むことになるため、結果的にフルスキャンが選ばれることが多い。

---

## 4. インデックスが効かない場合の対処法

* **アプリケーション制御**
    * UIで必須入力項目を設ける、期間指定を短く制限するなど、フルスキャンが発生するクエリを投げさせない。
* **データマート (Data Mart) の利用**

### データマート（Data Mart）概要

#### 概念
インデックスなどのDBMS内部のチューニングだけで高速化が困難な場合に検討する、**物理設計レベル**の対策。

#### 実態
巨大なテーブルから、特定の目的（月次レポート、特定画面用など）に必要な列・行だけを抽出・集計して作成した**「物理的な別テーブル」**。

#### なぜ速くなるのか
SQLのボトルネックである**「ストレージI/O」**を物理的に減らせるから。
* 1000万行から集計するのではなく、あらかじめ集計済みの100行のテーブルを読むだけで済む。

#### トレードオフ（注意点）
1. **データの鮮度:** 元テーブルからマートへデータをコピーするタイムラグがある（リアルタイムではない）。
2. **バッチ運用のコスト:** 定期的にデータを更新するバッチ処理の開発・運用が必要。
3. **ストレージ容量:** 同じデータの複製を持つことになるため、容量を圧迫する。