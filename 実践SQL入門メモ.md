## 結合アルゴリズムの比較まとめ

### 1. Nested Loops (入れ子ループ結合)
* **基本情報**:
    * 最も基本的でシンプル、頻繁に見るアルゴリズム。
    * 一方のテーブル（駆動表）を一行ずつ読み込み、そのレコードごとに結合条件に合うレコードをもう一方のテーブル（内部表）から探す。
    * 手続き型言語の二重ループと同じ構造で動作する。
* **特徴**:
    * 駆動表の行数が少ないほど、また内部表の結合キーにインデックスがあるほど高速になる。
    * 逆に駆動表が巨大でインデックスがない場合、パフォーマンスは劇的に悪化する。
    * 駆動表のキーが内部表でたくさんヒットしてしまうとループの数が多くなってしまうので遅い。
* **オプティマイザが選ぶ条件**:
    * 駆動表が十分に絞り込まれており、内部表の結合キーに適切なインデックスが存在する場合に好んで選択される。
* **駆動表を小さくすることが良いという理由**
    * 駆動表が小さければ小さいほど、「内部表へデータを見に行く回数」そのものを物理的に減らすことができるため、全体の処理時間が短縮する。(駆動表を小さく、内部表を大きくする。)
    * 内部表の結合キーにインデックスがある場合、1回あたりの検索は非常に高速になるから。

### 2. Hash (ハッシュ結合)
* **基本情報**:
    * 結合キーの値をハッシュ値にマッピングして結合を行う方式。
    * ハッシュテーブルを作成してメモリ上に展開するため、専用の作業用メモリ領域（ワーキングメモリ）を必要とする。
* **特徴**:
    * Nested Loopsに比べて、大量のデータを一度に処理するのに適している。
    * インデックスが存在しなくても、Nested Loopsより高速に動作する場合がある。
    * ただし、ワーキングメモリが不足すると「TEMP落ち」が発生し、低速になる。
* **オプティマイザが選ぶ条件**:
    * 結合対象のテーブルが大きく、適切なインデックスが存在しない場合や、Nested Loopsではコストが高いと判断された場合に選択される。

### 3. Sort Merge (ソートマージ結合)
* **基本情報**:
    * 結合キーで両方のレコードをソート（並べ替え）してから、順次アクセスして2つのテーブルを結合する方式。
* **特徴**:
    * ソート処理のために、ハッシュと同様にワーキングメモリ領域を必要とする。
    * 不等号（`<`, `>`）などのハッシュが苦手とする結合条件でも機能する。
    * データがソート済みでないと効率的ではない
* **オプティマイザが選ぶ条件**:
    * 対象のレコードが結合キーですでにソートされている場合や、等値結合以外の条件（範囲検索など）で結合を行う場合に選択される傾向がある。

---

### 補足
* **ワーキングメモリとパフォーマンス**: HashやSort Mergeは、一時的な作業領域としてワーキングメモリを使用する。このメモリが不足し、ストレージ上の一時領域（TEMP領域）が使われる状態を **「TEMP落ち」** と呼び、SQLの処理速度が急激に低下する主要な原因となる。そのため、複雑な結合を含む「ガツン系」のクエリを実行する際は、この領域の管理が重要になる
* MySQLにはSortアルゴリズムが存在しない