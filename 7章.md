# 7章まとめ

## 1. 基本

* サブクエリは便利だけど、結合増やしてパフォーマンス悪くなるのが基本
    * サブクエリ使うときは結合対象のレコードを先に絞り込んでから結合するとまだパフォーマンス良い。
* ストレージのI/O量を減らすのが、チューニングの基本原則
* 結合を使うクエリの不安定要素
    * 結合アルゴリズムの変動リスク (Nested Loops -> Hash)
        * システム稼働当初は、Nested Loopsだったのにデータ量が増えてきて、Hashになったなど。
---

## 2. 実践テクニック

### ① 自己結合より「ウィンドウ関数」
同じテーブル同士を結合（Self Join）して比較・集計するのは避ける。

* **理由:** 結合は計算量が $N \times M$ になりがちで、インデックスがないと致命的に遅くなる（Nested Loops → Hash Joinの変動リスク）。
* **対策:** ウィンドウ関数（`ROW_NUMBER`, `LAG` など）を使う。ソート済みのデータを1回走査（$N$）するだけで済むため、計算量が安定して低い。

### ② 結合の前に「集約」（Aggregate before Join）
行数が多いテーブルを結合する場合の鉄則。

* **悪い例:** `JOIN` してから `GROUP BY`
    * 100万行 × 10行 を結合 → 100万行の中間データ作成 → 集計。無駄が多い。
* **良い例:** サブクエリで `GROUP BY` してから `JOIN`
    * 100万行を先に集計して「数行」にする → その数行だけを結合。結合コストが激減する。

### ③ 計算の前に「絞り込み」
集計関数（SUMなど）に全データを渡さず、必要な行だけを渡す。

* **例:** 「最初の価格」と「最後の価格」の差額
    * 全件を `SUM` するのではなく、`ROW_NUMBER()` で `seq=1` の行だけを特定し、その行だけで計算を行う。

---

## サンプルコード：先に集約するパターン
主要なお店の従業員の合計を会社ごとに出力したいとき。


### テーブル

```sql
CREATE TABLE Companies
(
    co_cd    CHAR(3) NOT NULL,
    district CHAR(1) NOT NULL,
    CONSTRAINT pk_Companies PRIMARY KEY (co_cd)
);

INSERT INTO Companies VALUES ('001', 'A');
INSERT INTO Companies VALUES ('002', 'B');
INSERT INTO Companies VALUES ('003', 'C');
INSERT INTO Companies VALUES ('004', 'D');

CREATE TABLE Shops
(
    co_cd    CHAR(3) NOT NULL,
    shop_id  CHAR(3) NOT NULL,
    emp_nbr  INTEGER NOT NULL,
    main_flg CHAR(1) NOT NULL,
    CONSTRAINT pk_Shops PRIMARY KEY (co_cd, shop_id)
);

INSERT INTO Shops VALUES ('001', '1', 300, 'Y');
INSERT INTO Shops VALUES ('001', '2', 400, 'N');
INSERT INTO Shops VALUES ('001', '3', 250, 'Y');
INSERT INTO Shops VALUES ('002', '1', 100, 'Y');
INSERT INTO Shops VALUES ('002', '2', 20, 'N');
INSERT INTO Shops VALUES ('003', '1', 400, 'Y');
INSERT INTO Shops VALUES ('003', '2', 500, 'Y');
INSERT INTO Shops VALUES ('003', '3', 300, 'N');
INSERT INTO Shops VALUES ('003', '4', 200, 'Y');
INSERT INTO Shops VALUES ('004', '1', 999, 'Y');
```

```sql
SELECT 
    b.co_cd, 
    b.district, 
    a.sum_emp
FROM Companies b
INNER JOIN 
    (
        -- 【重要】ここで先に集計して、行数を減らしてから結合する
        SELECT 
            co_cd, 
            SUM(emp_nbr) as sum_emp
        FROM Shops
        WHERE main_flg = 'Y'
        GROUP BY co_cd
    ) a
    ON b.co_cd = a.co_cd;
```

## サンプルコード：自己結合 vs ウィンドウ関数
購入明細テーブルから、顧客IDごとに一番古い購入履歴を表示するクエリ。

```sql
CREATE TABLE Receipts
(
    cust_id  CHAR(1) NOT NULL,
    seq      INTEGER NOT NULL,
    price    INTEGER NOT NULL,
    CONSTRAINT pk_Receipts PRIMARY KEY (cust_id, seq)
);

INSERT INTO Receipts VALUES ('A', 1, 500);
INSERT INTO Receipts VALUES ('A', 2, 1000);
INSERT INTO Receipts VALUES ('A', 3, 700);
INSERT INTO Receipts VALUES ('B', 5, 100);
INSERT INTO Receipts VALUES ('B', 1, 600);
INSERT INTO Receipts VALUES ('B', 2, 2000);
INSERT INTO Receipts VALUES ('B', 3, 1500);
INSERT INTO Receipts VALUES ('C', 10, 800);
INSERT INTO Receipts VALUES ('C', 2, 400);
INSERT INTO Receipts VALUES ('D', 1, 900);
INSERT INTO Receipts VALUES ('D', 2, 200);
INSERT INTO Receipts VALUES ('D', 3, 50);
```

#### 悪い例（自己結合）
単純に結合すると2回データをスキャンすることになる。

```sql
SELECT a.cust_id, seq, price FROM Receipts a 
JOIN (SELECT cust_id, MIN(seq) as min_seq FROM Receipts GROUP BY cust_id) b
 ON (a.cust_id = b.cust_id and a.seq = b.min_seq);
```

#### 良い例（ウィンドウ関数）
ウィンドウ関数を使う方法。
テーブルスキャンは1回のみ

```sql
SELECT cust_id, seq, price FROM 
    (SELECT 
        cust_id,
        seq,
        price, 
        ROW_NUMBER() OVER (PARTITION BY cust_id ORDER BY seq) as row_seq
        FROM Receipts) a
WHERE a.row_seq = 1;
```